/**
 * This file was auto-generated by jswagger-swagger.
 * Do not make direct changes to the file.
 */

import {
  ApiRequestOptionsRX,
  ApiRequestOptionsRO,
  ApiRequestOptionsRR,
  ApiRequestOptionsOX,
  ApiRequestOptionsOO,
  ApiRequestOptionsOR,
  ApiRequestOptionsXX,
  ApiRequestOptionsXO,
  ApiRequestOptionsXR,
  ApiResponse,
  IApiSecurityContext,
  internal,
} from '../packages/client/src/';

const toClassValue = internal.toClassValue;
const toJsonObject = internal.toJsonObject;

const S_DEFINITION_NAME = Symbol('Definition Name');
const S_METHOD_TO_JSON_OBJECT = Symbol('toJsonObject');
const S_DEFINITION_METADATA = Symbol('Definition Metadata');
export type IJsonObject = any;

export namespace definition {
  export abstract class BaseClass {
    public abstract [S_METHOD_TO_JSON_OBJECT](): IJsonObject;
  }
  export interface definitions {
    /**
     * types test
     */
    ManyTypes: {
      number32?: number;
      number64?: number;
      simpleText?: string;
      binaryText?: string;
      timestamp?: string;
    };
    ManyTypesApiResponse: {
      code?: number;
      message?: string;
      result?: definitions['ManyTypes'];
    };
    /**
     * ok
     */
    LightingSummary: {
      zones?: definitions['LightingZone'][];
      zoneStatus?: definitions['LightingZoneStatus'][];
    };
    LightingZone: {
      id?: string;
      name?: string;
      deviceId?: number;
      deviceType?: 'dimmer' | 'switch';
      zone?: string;
    };
    /**
     * the status of the lighting zone.
     */
    LightingZoneStatus: {
      id?: string;
      name?: string;
      lastUpdate?: string;
      level?: number;
    };
    /**
     * ok
     */
    TemperatureSummary: {
      zones?: definitions['TemperatureZone'][];
      zoneStatus?: definitions['TemperatueZoneStatus'][];
    };
    /**
     * a single temperature zone
     */
    TemperatureZone: {
      /**
       * the unique identifier for the zone
       */
      id: number;
      name: string;
      inputPosition?: number;
      outputPosition?: number;
      zone?: string;
    };
    /**
     * status of a single zone
     */
    TemperatueZoneStatus: {
      /**
       * the unique identifier for the zone
       */
      id: string;
      /**
       * the name of the zone
       */
      name?: string;
      /**
       * the temperature in the zone
       */
      value: number;
      /**
       * the temperature units
       */
      units?: 'celsius' | 'fahrenheit';
      /**
       * the timestamp when the temperature was measured
       */
      timestamp: string;
    };
    ApiResponse: { code?: number; message?: string };
    HeaterState: { id?: string; state?: string };
    DeviceState: {
      id?: string;
      name?: string;
      lastUpdate?: string;
      level?: number;
    };
    ForecastResponse: {
      city?: definitions['City'];
      values?: definitions['Forecast'][];
    };
    Forecast: {
      date?: string;
      pressure?: number;
      humidity?: number;
      windSpeed?: number;
      clouds?: number;
      temperature?: definitions['ForecastTemperature'];
      weather?: definitions['WeatherForecast'];
    };
    City: {
      id?: number;
      name?: string;
      lat?: number;
      lon?: number;
      country?: string;
    };
    ForecastTemperature: {
      low?: number;
      high?: number;
      morning?: number;
      day?: number;
      evening?: number;
      night?: number;
    };
    WeatherForecast: { summary?: string; description?: string; icon?: string };
    DeviceRegistrationInfo: { uri?: string; id?: string };
  }
  export type IManyTypes = definitions['ManyTypes'];
  export type IManyTypesApiResponse = definitions['ManyTypesApiResponse'];
  export type ILightingSummary = definitions['LightingSummary'];
  export type ILightingZone = definitions['LightingZone'];
  export type ILightingZoneStatus = definitions['LightingZoneStatus'];
  export type ITemperatureSummary = definitions['TemperatureSummary'];
  export type ITemperatureZone = definitions['TemperatureZone'];
  export type ITemperatueZoneStatus = definitions['TemperatueZoneStatus'];
  export type IApiResponse = definitions['ApiResponse'];
  export type IHeaterState = definitions['HeaterState'];
  export type IDeviceState = definitions['DeviceState'];
  export type IForecastResponse = definitions['ForecastResponse'];
  export type IForecast = definitions['Forecast'];
  export type ICity = definitions['City'];
  export type IForecastTemperature = definitions['ForecastTemperature'];
  export type IWeatherForecast = definitions['WeatherForecast'];
  export type IDeviceRegistrationInfo = definitions['DeviceRegistrationInfo'];
  export class ManyTypes extends BaseClass {
    'number32'?: number;
    'number64'?: number;
    'simpleText'?: string;
    'binaryText'?: Buffer;
    'timestamp'?: Date;

    public static SWAGGER_DEFINITION_NAME = 'ManyTypes';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IManyTypes }) {
      super();
      this[S_DEFINITION_NAME] = 'ManyTypes';
      const schema = (params && params.schema) || ({} as any);
      this.number32 = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'number32',
        schema.number32
      );
      this.number64 = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'number64',
        schema.number64
      );
      this.simpleText = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'simpleText',
        schema.simpleText
      );
      this.binaryText = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'binaryText',
        schema.binaryText
      );
      this.timestamp = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'timestamp',
        schema.timestamp
      );
    }

    public _assignFrom(schema: IManyTypes) {
      this.number32 = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'number32',
        schema.number32
      );
      this.number64 = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'number64',
        schema.number64
      );
      this.simpleText = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'simpleText',
        schema.simpleText
      );
      this.binaryText = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'binaryText',
        schema.binaryText
      );
      this.timestamp = toClassValue(
        metadata,
        ManyTypes[S_DEFINITION_METADATA],
        'timestamp',
        schema.timestamp
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === ManyTypes.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        number32: toJsonObject(
          metadata,
          ManyTypes[S_DEFINITION_METADATA],
          'number32',
          this['number32']
        ),
        number64: toJsonObject(
          metadata,
          ManyTypes[S_DEFINITION_METADATA],
          'number64',
          this['number64']
        ),
        simpleText: toJsonObject(
          metadata,
          ManyTypes[S_DEFINITION_METADATA],
          'simpleText',
          this['simpleText']
        ),
        binaryText: toJsonObject(
          metadata,
          ManyTypes[S_DEFINITION_METADATA],
          'binaryText',
          this['binaryText']
        ),
        timestamp: toJsonObject(
          metadata,
          ManyTypes[S_DEFINITION_METADATA],
          'timestamp',
          this['timestamp']
        ),
      };
    }
  }

  Object.defineProperty(ManyTypes, S_DEFINITION_NAME, {
    get: () => 'ManyTypes',
  });

  Object.defineProperty(ManyTypes, S_DEFINITION_METADATA, {
    get: () => ({
      number32: { type: 'integer', format: 'int32' },
      number64: { type: 'integer', format: 'int64' },
      simpleText: { type: 'string' },
      binaryText: { type: 'string', format: 'byte' },
      timestamp: { type: 'string', format: 'date-time' },
    }),
  });

  export class ManyTypesApiResponse extends BaseClass {
    'code'?: number;
    'message'?: string;
    'result'?: definitions['ManyTypes'];

    public static SWAGGER_DEFINITION_NAME = 'ManyTypesApiResponse';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IManyTypesApiResponse }) {
      super();
      this[S_DEFINITION_NAME] = 'ManyTypesApiResponse';
      const schema = (params && params.schema) || ({} as any);
      this.code = toClassValue(
        metadata,
        ManyTypesApiResponse[S_DEFINITION_METADATA],
        'code',
        schema.code
      );
      this.message = toClassValue(
        metadata,
        ManyTypesApiResponse[S_DEFINITION_METADATA],
        'message',
        schema.message
      );
      this.result = toClassValue(
        metadata,
        ManyTypesApiResponse[S_DEFINITION_METADATA],
        'result',
        schema.result
      );
    }

    public _assignFrom(schema: IManyTypesApiResponse) {
      this.code = toClassValue(
        metadata,
        ManyTypesApiResponse[S_DEFINITION_METADATA],
        'code',
        schema.code
      );
      this.message = toClassValue(
        metadata,
        ManyTypesApiResponse[S_DEFINITION_METADATA],
        'message',
        schema.message
      );
      this.result = toClassValue(
        metadata,
        ManyTypesApiResponse[S_DEFINITION_METADATA],
        'result',
        schema.result
      );
    }

    public static isInstance(o: any): boolean {
      return (
        o[S_DEFINITION_NAME] === ManyTypesApiResponse.SWAGGER_DEFINITION_NAME
      );
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        code: toJsonObject(
          metadata,
          ManyTypesApiResponse[S_DEFINITION_METADATA],
          'code',
          this['code']
        ),
        message: toJsonObject(
          metadata,
          ManyTypesApiResponse[S_DEFINITION_METADATA],
          'message',
          this['message']
        ),
        result: toJsonObject(
          metadata,
          ManyTypesApiResponse[S_DEFINITION_METADATA],
          'result',
          this['result']
        ),
      };
    }
  }

  Object.defineProperty(ManyTypesApiResponse, S_DEFINITION_NAME, {
    get: () => 'ManyTypesApiResponse',
  });

  Object.defineProperty(ManyTypesApiResponse, S_DEFINITION_METADATA, {
    get: () => ({
      code: { type: 'integer', format: 'int32' },
      message: { type: 'string', example: 'everything is ok' },
      result: { $ref: '#/definitions/ManyTypes' },
    }),
  });

  export class LightingSummary extends BaseClass {
    'zones'?: definitions['LightingZone'][];
    'zoneStatus'?: definitions['LightingZoneStatus'][];

    public static SWAGGER_DEFINITION_NAME = 'LightingSummary';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ILightingSummary }) {
      super();
      this[S_DEFINITION_NAME] = 'LightingSummary';
      const schema = (params && params.schema) || ({} as any);
      this.zones = toClassValue(
        metadata,
        LightingSummary[S_DEFINITION_METADATA],
        'zones',
        schema.zones
      );
      this.zoneStatus = toClassValue(
        metadata,
        LightingSummary[S_DEFINITION_METADATA],
        'zoneStatus',
        schema.zoneStatus
      );
    }

    public _assignFrom(schema: ILightingSummary) {
      this.zones = toClassValue(
        metadata,
        LightingSummary[S_DEFINITION_METADATA],
        'zones',
        schema.zones
      );
      this.zoneStatus = toClassValue(
        metadata,
        LightingSummary[S_DEFINITION_METADATA],
        'zoneStatus',
        schema.zoneStatus
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === LightingSummary.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        zones: toJsonObject(
          metadata,
          LightingSummary[S_DEFINITION_METADATA],
          'zones',
          this['zones']
        ),
        zoneStatus: toJsonObject(
          metadata,
          LightingSummary[S_DEFINITION_METADATA],
          'zoneStatus',
          this['zoneStatus']
        ),
      };
    }
  }

  Object.defineProperty(LightingSummary, S_DEFINITION_NAME, {
    get: () => 'LightingSummary',
  });

  Object.defineProperty(LightingSummary, S_DEFINITION_METADATA, {
    get: () => ({
      zones: { type: 'array', items: { $ref: '#/definitions/LightingZone' } },
      zoneStatus: {
        type: 'array',
        items: { $ref: '#/definitions/LightingZoneStatus' },
      },
    }),
  });

  export class LightingZone extends BaseClass {
    'id'?: string;
    'name'?: string;
    'deviceId'?: number;
    'deviceType'?: 'dimmer' | 'switch';
    'zone'?: string;

    public static SWAGGER_DEFINITION_NAME = 'LightingZone';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ILightingZone }) {
      super();
      this[S_DEFINITION_NAME] = 'LightingZone';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.deviceId = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'deviceId',
        schema.deviceId
      );
      this.deviceType = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'deviceType',
        schema.deviceType
      );
      this.zone = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'zone',
        schema.zone
      );
    }

    public _assignFrom(schema: ILightingZone) {
      this.id = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.deviceId = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'deviceId',
        schema.deviceId
      );
      this.deviceType = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'deviceType',
        schema.deviceType
      );
      this.zone = toClassValue(
        metadata,
        LightingZone[S_DEFINITION_METADATA],
        'zone',
        schema.zone
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === LightingZone.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          LightingZone[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        name: toJsonObject(
          metadata,
          LightingZone[S_DEFINITION_METADATA],
          'name',
          this['name']
        ),
        deviceId: toJsonObject(
          metadata,
          LightingZone[S_DEFINITION_METADATA],
          'deviceId',
          this['deviceId']
        ),
        deviceType: toJsonObject(
          metadata,
          LightingZone[S_DEFINITION_METADATA],
          'deviceType',
          this['deviceType']
        ),
        zone: toJsonObject(
          metadata,
          LightingZone[S_DEFINITION_METADATA],
          'zone',
          this['zone']
        ),
      };
    }
  }

  Object.defineProperty(LightingZone, S_DEFINITION_NAME, {
    get: () => 'LightingZone',
  });

  Object.defineProperty(LightingZone, S_DEFINITION_METADATA, {
    get: () => ({
      id: { type: 'string' },
      name: { type: 'string' },
      deviceId: { type: 'integer', format: 'int32' },
      deviceType: { type: 'string', enum: ['dimmer', 'switch'] },
      zone: { type: 'string' },
    }),
  });

  export class LightingZoneStatus extends BaseClass {
    'id'?: string;
    'name'?: string;
    'lastUpdate'?: Date;
    'level'?: number;

    public static SWAGGER_DEFINITION_NAME = 'LightingZoneStatus';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ILightingZoneStatus }) {
      super();
      this[S_DEFINITION_NAME] = 'LightingZoneStatus';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.lastUpdate = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'lastUpdate',
        schema.lastUpdate
      );
      this.level = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'level',
        schema.level
      );
    }

    public _assignFrom(schema: ILightingZoneStatus) {
      this.id = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.lastUpdate = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'lastUpdate',
        schema.lastUpdate
      );
      this.level = toClassValue(
        metadata,
        LightingZoneStatus[S_DEFINITION_METADATA],
        'level',
        schema.level
      );
    }

    public static isInstance(o: any): boolean {
      return (
        o[S_DEFINITION_NAME] === LightingZoneStatus.SWAGGER_DEFINITION_NAME
      );
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          LightingZoneStatus[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        name: toJsonObject(
          metadata,
          LightingZoneStatus[S_DEFINITION_METADATA],
          'name',
          this['name']
        ),
        lastUpdate: toJsonObject(
          metadata,
          LightingZoneStatus[S_DEFINITION_METADATA],
          'lastUpdate',
          this['lastUpdate']
        ),
        level: toJsonObject(
          metadata,
          LightingZoneStatus[S_DEFINITION_METADATA],
          'level',
          this['level']
        ),
      };
    }
  }

  Object.defineProperty(LightingZoneStatus, S_DEFINITION_NAME, {
    get: () => 'LightingZoneStatus',
  });

  Object.defineProperty(LightingZoneStatus, S_DEFINITION_METADATA, {
    get: () => ({
      id: { type: 'string' },
      name: { type: 'string' },
      lastUpdate: { type: 'string', format: 'date-time' },
      level: { type: 'integer', format: 'int32' },
    }),
  });

  export class TemperatureSummary extends BaseClass {
    'zones'?: definitions['TemperatureZone'][];
    'zoneStatus'?: definitions['TemperatueZoneStatus'][];

    public static SWAGGER_DEFINITION_NAME = 'TemperatureSummary';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ITemperatureSummary }) {
      super();
      this[S_DEFINITION_NAME] = 'TemperatureSummary';
      const schema = (params && params.schema) || ({} as any);
      this.zones = toClassValue(
        metadata,
        TemperatureSummary[S_DEFINITION_METADATA],
        'zones',
        schema.zones
      );
      this.zoneStatus = toClassValue(
        metadata,
        TemperatureSummary[S_DEFINITION_METADATA],
        'zoneStatus',
        schema.zoneStatus
      );
    }

    public _assignFrom(schema: ITemperatureSummary) {
      this.zones = toClassValue(
        metadata,
        TemperatureSummary[S_DEFINITION_METADATA],
        'zones',
        schema.zones
      );
      this.zoneStatus = toClassValue(
        metadata,
        TemperatureSummary[S_DEFINITION_METADATA],
        'zoneStatus',
        schema.zoneStatus
      );
    }

    public static isInstance(o: any): boolean {
      return (
        o[S_DEFINITION_NAME] === TemperatureSummary.SWAGGER_DEFINITION_NAME
      );
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        zones: toJsonObject(
          metadata,
          TemperatureSummary[S_DEFINITION_METADATA],
          'zones',
          this['zones']
        ),
        zoneStatus: toJsonObject(
          metadata,
          TemperatureSummary[S_DEFINITION_METADATA],
          'zoneStatus',
          this['zoneStatus']
        ),
      };
    }
  }

  Object.defineProperty(TemperatureSummary, S_DEFINITION_NAME, {
    get: () => 'TemperatureSummary',
  });

  Object.defineProperty(TemperatureSummary, S_DEFINITION_METADATA, {
    get: () => ({
      zones: {
        type: 'array',
        items: { $ref: '#/definitions/TemperatureZone' },
      },
      zoneStatus: {
        type: 'array',
        items: { $ref: '#/definitions/TemperatueZoneStatus' },
      },
    }),
  });

  export class TemperatureZone extends BaseClass {
    /**
     * the unique identifier for the zone
     */
    'id': number;
    'name': string;
    'inputPosition'?: number;
    'outputPosition'?: number;
    'zone'?: string;

    public static SWAGGER_DEFINITION_NAME = 'TemperatureZone';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ITemperatureZone }) {
      super();
      this[S_DEFINITION_NAME] = 'TemperatureZone';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.inputPosition = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'inputPosition',
        schema.inputPosition
      );
      this.outputPosition = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'outputPosition',
        schema.outputPosition
      );
      this.zone = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'zone',
        schema.zone
      );
    }

    public _assignFrom(schema: ITemperatureZone) {
      this.id = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.inputPosition = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'inputPosition',
        schema.inputPosition
      );
      this.outputPosition = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'outputPosition',
        schema.outputPosition
      );
      this.zone = toClassValue(
        metadata,
        TemperatureZone[S_DEFINITION_METADATA],
        'zone',
        schema.zone
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === TemperatureZone.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          TemperatureZone[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        name: toJsonObject(
          metadata,
          TemperatureZone[S_DEFINITION_METADATA],
          'name',
          this['name']
        ),
        inputPosition: toJsonObject(
          metadata,
          TemperatureZone[S_DEFINITION_METADATA],
          'inputPosition',
          this['inputPosition']
        ),
        outputPosition: toJsonObject(
          metadata,
          TemperatureZone[S_DEFINITION_METADATA],
          'outputPosition',
          this['outputPosition']
        ),
        zone: toJsonObject(
          metadata,
          TemperatureZone[S_DEFINITION_METADATA],
          'zone',
          this['zone']
        ),
      };
    }
  }

  Object.defineProperty(TemperatureZone, S_DEFINITION_NAME, {
    get: () => 'TemperatureZone',
  });

  Object.defineProperty(TemperatureZone, S_DEFINITION_METADATA, {
    get: () => ({
      id: {
        type: 'integer',
        format: 'int32',
        description: 'the unique identifier for the zone',
      },
      name: { type: 'string' },
      inputPosition: { type: 'integer', format: 'int32' },
      outputPosition: { type: 'integer', format: 'int32' },
      zone: { type: 'string' },
    }),
  });

  export class TemperatueZoneStatus extends BaseClass {
    /**
     * the unique identifier for the zone
     */
    'id': string;
    /**
     * the name of the zone
     */
    'name'?: string;
    /**
     * the temperature in the zone
     */
    'value': number;
    /**
     * the temperature units
     */
    'units'?: 'celsius' | 'fahrenheit';
    /**
     * the timestamp when the temperature was measured
     */
    'timestamp': Date;

    public static SWAGGER_DEFINITION_NAME = 'TemperatueZoneStatus';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ITemperatueZoneStatus }) {
      super();
      this[S_DEFINITION_NAME] = 'TemperatueZoneStatus';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.value = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'value',
        schema.value
      );
      this.units = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'units',
        schema.units
      );
      this.timestamp = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'timestamp',
        schema.timestamp
      );
    }

    public _assignFrom(schema: ITemperatueZoneStatus) {
      this.id = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.value = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'value',
        schema.value
      );
      this.units = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'units',
        schema.units
      );
      this.timestamp = toClassValue(
        metadata,
        TemperatueZoneStatus[S_DEFINITION_METADATA],
        'timestamp',
        schema.timestamp
      );
    }

    public static isInstance(o: any): boolean {
      return (
        o[S_DEFINITION_NAME] === TemperatueZoneStatus.SWAGGER_DEFINITION_NAME
      );
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          TemperatueZoneStatus[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        name: toJsonObject(
          metadata,
          TemperatueZoneStatus[S_DEFINITION_METADATA],
          'name',
          this['name']
        ),
        value: toJsonObject(
          metadata,
          TemperatueZoneStatus[S_DEFINITION_METADATA],
          'value',
          this['value']
        ),
        units: toJsonObject(
          metadata,
          TemperatueZoneStatus[S_DEFINITION_METADATA],
          'units',
          this['units']
        ),
        timestamp: toJsonObject(
          metadata,
          TemperatueZoneStatus[S_DEFINITION_METADATA],
          'timestamp',
          this['timestamp']
        ),
      };
    }
  }

  Object.defineProperty(TemperatueZoneStatus, S_DEFINITION_NAME, {
    get: () => 'TemperatueZoneStatus',
  });

  Object.defineProperty(TemperatueZoneStatus, S_DEFINITION_METADATA, {
    get: () => ({
      id: { type: 'string', description: 'the unique identifier for the zone' },
      name: { type: 'string', description: 'the name of the zone' },
      value: {
        type: 'number',
        format: 'double',
        description: 'the temperature in the zone',
      },
      units: {
        type: 'string',
        description: 'the temperature units',
        enum: ['celsius', 'fahrenheit'],
        default: 'fahrenheit',
      },
      timestamp: {
        type: 'string',
        format: 'date-time',
        description: 'the timestamp when the temperature was measured',
      },
    }),
  });

  export class ApiResponse extends BaseClass {
    'code'?: number;
    'message'?: string;

    public static SWAGGER_DEFINITION_NAME = 'ApiResponse';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IApiResponse }) {
      super();
      this[S_DEFINITION_NAME] = 'ApiResponse';
      const schema = (params && params.schema) || ({} as any);
      this.code = toClassValue(
        metadata,
        ApiResponse[S_DEFINITION_METADATA],
        'code',
        schema.code
      );
      this.message = toClassValue(
        metadata,
        ApiResponse[S_DEFINITION_METADATA],
        'message',
        schema.message
      );
    }

    public _assignFrom(schema: IApiResponse) {
      this.code = toClassValue(
        metadata,
        ApiResponse[S_DEFINITION_METADATA],
        'code',
        schema.code
      );
      this.message = toClassValue(
        metadata,
        ApiResponse[S_DEFINITION_METADATA],
        'message',
        schema.message
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === ApiResponse.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        code: toJsonObject(
          metadata,
          ApiResponse[S_DEFINITION_METADATA],
          'code',
          this['code']
        ),
        message: toJsonObject(
          metadata,
          ApiResponse[S_DEFINITION_METADATA],
          'message',
          this['message']
        ),
      };
    }
  }

  Object.defineProperty(ApiResponse, S_DEFINITION_NAME, {
    get: () => 'ApiResponse',
  });

  Object.defineProperty(ApiResponse, S_DEFINITION_METADATA, {
    get: () => ({
      code: { type: 'integer', format: 'int32' },
      message: { type: 'string', example: 'everything is ok' },
    }),
  });

  export class HeaterState extends BaseClass {
    'id'?: string;
    'state'?: string;

    public static SWAGGER_DEFINITION_NAME = 'HeaterState';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IHeaterState }) {
      super();
      this[S_DEFINITION_NAME] = 'HeaterState';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        HeaterState[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.state = toClassValue(
        metadata,
        HeaterState[S_DEFINITION_METADATA],
        'state',
        schema.state
      );
    }

    public _assignFrom(schema: IHeaterState) {
      this.id = toClassValue(
        metadata,
        HeaterState[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.state = toClassValue(
        metadata,
        HeaterState[S_DEFINITION_METADATA],
        'state',
        schema.state
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === HeaterState.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          HeaterState[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        state: toJsonObject(
          metadata,
          HeaterState[S_DEFINITION_METADATA],
          'state',
          this['state']
        ),
      };
    }
  }

  Object.defineProperty(HeaterState, S_DEFINITION_NAME, {
    get: () => 'HeaterState',
  });

  Object.defineProperty(HeaterState, S_DEFINITION_METADATA, {
    get: () => ({ id: { type: 'string' }, state: { type: 'string' } }),
  });

  export class DeviceState extends BaseClass {
    'id'?: string;
    'name'?: string;
    'lastUpdate'?: Date;
    'level'?: number;

    public static SWAGGER_DEFINITION_NAME = 'DeviceState';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IDeviceState }) {
      super();
      this[S_DEFINITION_NAME] = 'DeviceState';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.lastUpdate = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'lastUpdate',
        schema.lastUpdate
      );
      this.level = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'level',
        schema.level
      );
    }

    public _assignFrom(schema: IDeviceState) {
      this.id = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.lastUpdate = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'lastUpdate',
        schema.lastUpdate
      );
      this.level = toClassValue(
        metadata,
        DeviceState[S_DEFINITION_METADATA],
        'level',
        schema.level
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === DeviceState.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          DeviceState[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        name: toJsonObject(
          metadata,
          DeviceState[S_DEFINITION_METADATA],
          'name',
          this['name']
        ),
        lastUpdate: toJsonObject(
          metadata,
          DeviceState[S_DEFINITION_METADATA],
          'lastUpdate',
          this['lastUpdate']
        ),
        level: toJsonObject(
          metadata,
          DeviceState[S_DEFINITION_METADATA],
          'level',
          this['level']
        ),
      };
    }
  }

  Object.defineProperty(DeviceState, S_DEFINITION_NAME, {
    get: () => 'DeviceState',
  });

  Object.defineProperty(DeviceState, S_DEFINITION_METADATA, {
    get: () => ({
      id: { type: 'string' },
      name: { type: 'string' },
      lastUpdate: { type: 'string', format: 'date-time' },
      level: { type: 'integer', format: 'int32' },
    }),
  });

  export class ForecastResponse extends BaseClass {
    'city'?: definitions['City'];
    'values'?: definitions['Forecast'][];

    public static SWAGGER_DEFINITION_NAME = 'ForecastResponse';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IForecastResponse }) {
      super();
      this[S_DEFINITION_NAME] = 'ForecastResponse';
      const schema = (params && params.schema) || ({} as any);
      this.city = toClassValue(
        metadata,
        ForecastResponse[S_DEFINITION_METADATA],
        'city',
        schema.city
      );
      this.values = toClassValue(
        metadata,
        ForecastResponse[S_DEFINITION_METADATA],
        'values',
        schema.values
      );
    }

    public _assignFrom(schema: IForecastResponse) {
      this.city = toClassValue(
        metadata,
        ForecastResponse[S_DEFINITION_METADATA],
        'city',
        schema.city
      );
      this.values = toClassValue(
        metadata,
        ForecastResponse[S_DEFINITION_METADATA],
        'values',
        schema.values
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === ForecastResponse.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        city: toJsonObject(
          metadata,
          ForecastResponse[S_DEFINITION_METADATA],
          'city',
          this['city']
        ),
        values: toJsonObject(
          metadata,
          ForecastResponse[S_DEFINITION_METADATA],
          'values',
          this['values']
        ),
      };
    }
  }

  Object.defineProperty(ForecastResponse, S_DEFINITION_NAME, {
    get: () => 'ForecastResponse',
  });

  Object.defineProperty(ForecastResponse, S_DEFINITION_METADATA, {
    get: () => ({
      city: { $ref: '#/definitions/City' },
      values: { type: 'array', items: { $ref: '#/definitions/Forecast' } },
    }),
  });

  export class Forecast extends BaseClass {
    'date'?: Date;
    'pressure'?: number;
    'humidity'?: number;
    'windSpeed'?: number;
    'clouds'?: number;
    'temperature'?: definitions['ForecastTemperature'];
    'weather'?: definitions['WeatherForecast'];

    public static SWAGGER_DEFINITION_NAME = 'Forecast';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IForecast }) {
      super();
      this[S_DEFINITION_NAME] = 'Forecast';
      const schema = (params && params.schema) || ({} as any);
      this.date = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'date',
        schema.date
      );
      this.pressure = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'pressure',
        schema.pressure
      );
      this.humidity = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'humidity',
        schema.humidity
      );
      this.windSpeed = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'windSpeed',
        schema.windSpeed
      );
      this.clouds = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'clouds',
        schema.clouds
      );
      this.temperature = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'temperature',
        schema.temperature
      );
      this.weather = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'weather',
        schema.weather
      );
    }

    public _assignFrom(schema: IForecast) {
      this.date = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'date',
        schema.date
      );
      this.pressure = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'pressure',
        schema.pressure
      );
      this.humidity = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'humidity',
        schema.humidity
      );
      this.windSpeed = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'windSpeed',
        schema.windSpeed
      );
      this.clouds = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'clouds',
        schema.clouds
      );
      this.temperature = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'temperature',
        schema.temperature
      );
      this.weather = toClassValue(
        metadata,
        Forecast[S_DEFINITION_METADATA],
        'weather',
        schema.weather
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === Forecast.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        date: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'date',
          this['date']
        ),
        pressure: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'pressure',
          this['pressure']
        ),
        humidity: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'humidity',
          this['humidity']
        ),
        windSpeed: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'windSpeed',
          this['windSpeed']
        ),
        clouds: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'clouds',
          this['clouds']
        ),
        temperature: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'temperature',
          this['temperature']
        ),
        weather: toJsonObject(
          metadata,
          Forecast[S_DEFINITION_METADATA],
          'weather',
          this['weather']
        ),
      };
    }
  }

  Object.defineProperty(Forecast, S_DEFINITION_NAME, {
    get: () => 'Forecast',
  });

  Object.defineProperty(Forecast, S_DEFINITION_METADATA, {
    get: () => ({
      date: { type: 'string', format: 'date-time' },
      pressure: { type: 'number', format: 'double' },
      humidity: { type: 'integer', format: 'int32' },
      windSpeed: { type: 'number', format: 'double' },
      clouds: { type: 'integer', format: 'int32' },
      temperature: { $ref: '#/definitions/ForecastTemperature' },
      weather: { $ref: '#/definitions/WeatherForecast' },
    }),
  });

  export class City extends BaseClass {
    'id'?: number;
    'name'?: string;
    'lat'?: number;
    'lon'?: number;
    'country'?: string;

    public static SWAGGER_DEFINITION_NAME = 'City';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: ICity }) {
      super();
      this[S_DEFINITION_NAME] = 'City';
      const schema = (params && params.schema) || ({} as any);
      this.id = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.lat = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'lat',
        schema.lat
      );
      this.lon = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'lon',
        schema.lon
      );
      this.country = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'country',
        schema.country
      );
    }

    public _assignFrom(schema: ICity) {
      this.id = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
      this.name = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'name',
        schema.name
      );
      this.lat = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'lat',
        schema.lat
      );
      this.lon = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'lon',
        schema.lon
      );
      this.country = toClassValue(
        metadata,
        City[S_DEFINITION_METADATA],
        'country',
        schema.country
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === City.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        id: toJsonObject(
          metadata,
          City[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
        name: toJsonObject(
          metadata,
          City[S_DEFINITION_METADATA],
          'name',
          this['name']
        ),
        lat: toJsonObject(
          metadata,
          City[S_DEFINITION_METADATA],
          'lat',
          this['lat']
        ),
        lon: toJsonObject(
          metadata,
          City[S_DEFINITION_METADATA],
          'lon',
          this['lon']
        ),
        country: toJsonObject(
          metadata,
          City[S_DEFINITION_METADATA],
          'country',
          this['country']
        ),
      };
    }
  }

  Object.defineProperty(City, S_DEFINITION_NAME, {
    get: () => 'City',
  });

  Object.defineProperty(City, S_DEFINITION_METADATA, {
    get: () => ({
      id: { type: 'integer', format: 'int64' },
      name: { type: 'string' },
      lat: { type: 'number', format: 'double' },
      lon: { type: 'number', format: 'double' },
      country: { type: 'string' },
    }),
  });

  export class ForecastTemperature extends BaseClass {
    'low'?: number;
    'high'?: number;
    'morning'?: number;
    'day'?: number;
    'evening'?: number;
    'night'?: number;

    public static SWAGGER_DEFINITION_NAME = 'ForecastTemperature';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IForecastTemperature }) {
      super();
      this[S_DEFINITION_NAME] = 'ForecastTemperature';
      const schema = (params && params.schema) || ({} as any);
      this.low = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'low',
        schema.low
      );
      this.high = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'high',
        schema.high
      );
      this.morning = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'morning',
        schema.morning
      );
      this.day = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'day',
        schema.day
      );
      this.evening = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'evening',
        schema.evening
      );
      this.night = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'night',
        schema.night
      );
    }

    public _assignFrom(schema: IForecastTemperature) {
      this.low = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'low',
        schema.low
      );
      this.high = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'high',
        schema.high
      );
      this.morning = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'morning',
        schema.morning
      );
      this.day = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'day',
        schema.day
      );
      this.evening = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'evening',
        schema.evening
      );
      this.night = toClassValue(
        metadata,
        ForecastTemperature[S_DEFINITION_METADATA],
        'night',
        schema.night
      );
    }

    public static isInstance(o: any): boolean {
      return (
        o[S_DEFINITION_NAME] === ForecastTemperature.SWAGGER_DEFINITION_NAME
      );
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        low: toJsonObject(
          metadata,
          ForecastTemperature[S_DEFINITION_METADATA],
          'low',
          this['low']
        ),
        high: toJsonObject(
          metadata,
          ForecastTemperature[S_DEFINITION_METADATA],
          'high',
          this['high']
        ),
        morning: toJsonObject(
          metadata,
          ForecastTemperature[S_DEFINITION_METADATA],
          'morning',
          this['morning']
        ),
        day: toJsonObject(
          metadata,
          ForecastTemperature[S_DEFINITION_METADATA],
          'day',
          this['day']
        ),
        evening: toJsonObject(
          metadata,
          ForecastTemperature[S_DEFINITION_METADATA],
          'evening',
          this['evening']
        ),
        night: toJsonObject(
          metadata,
          ForecastTemperature[S_DEFINITION_METADATA],
          'night',
          this['night']
        ),
      };
    }
  }

  Object.defineProperty(ForecastTemperature, S_DEFINITION_NAME, {
    get: () => 'ForecastTemperature',
  });

  Object.defineProperty(ForecastTemperature, S_DEFINITION_METADATA, {
    get: () => ({
      low: { type: 'number', format: 'double' },
      high: { type: 'number', format: 'double' },
      morning: { type: 'number', format: 'double' },
      day: { type: 'number', format: 'double' },
      evening: { type: 'number', format: 'double' },
      night: { type: 'number', format: 'double' },
    }),
  });

  export class WeatherForecast extends BaseClass {
    'summary'?: string;
    'description'?: string;
    'icon'?: string;

    public static SWAGGER_DEFINITION_NAME = 'WeatherForecast';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IWeatherForecast }) {
      super();
      this[S_DEFINITION_NAME] = 'WeatherForecast';
      const schema = (params && params.schema) || ({} as any);
      this.summary = toClassValue(
        metadata,
        WeatherForecast[S_DEFINITION_METADATA],
        'summary',
        schema.summary
      );
      this.description = toClassValue(
        metadata,
        WeatherForecast[S_DEFINITION_METADATA],
        'description',
        schema.description
      );
      this.icon = toClassValue(
        metadata,
        WeatherForecast[S_DEFINITION_METADATA],
        'icon',
        schema.icon
      );
    }

    public _assignFrom(schema: IWeatherForecast) {
      this.summary = toClassValue(
        metadata,
        WeatherForecast[S_DEFINITION_METADATA],
        'summary',
        schema.summary
      );
      this.description = toClassValue(
        metadata,
        WeatherForecast[S_DEFINITION_METADATA],
        'description',
        schema.description
      );
      this.icon = toClassValue(
        metadata,
        WeatherForecast[S_DEFINITION_METADATA],
        'icon',
        schema.icon
      );
    }

    public static isInstance(o: any): boolean {
      return o[S_DEFINITION_NAME] === WeatherForecast.SWAGGER_DEFINITION_NAME;
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        summary: toJsonObject(
          metadata,
          WeatherForecast[S_DEFINITION_METADATA],
          'summary',
          this['summary']
        ),
        description: toJsonObject(
          metadata,
          WeatherForecast[S_DEFINITION_METADATA],
          'description',
          this['description']
        ),
        icon: toJsonObject(
          metadata,
          WeatherForecast[S_DEFINITION_METADATA],
          'icon',
          this['icon']
        ),
      };
    }
  }

  Object.defineProperty(WeatherForecast, S_DEFINITION_NAME, {
    get: () => 'WeatherForecast',
  });

  Object.defineProperty(WeatherForecast, S_DEFINITION_METADATA, {
    get: () => ({
      summary: { type: 'string' },
      description: { type: 'string' },
      icon: { type: 'string' },
    }),
  });

  export class DeviceRegistrationInfo extends BaseClass {
    'uri'?: string;
    'id'?: string;

    public static SWAGGER_DEFINITION_NAME = 'DeviceRegistrationInfo';
    public readonly [S_DEFINITION_NAME]: string;

    public constructor(params?: { schema?: IDeviceRegistrationInfo }) {
      super();
      this[S_DEFINITION_NAME] = 'DeviceRegistrationInfo';
      const schema = (params && params.schema) || ({} as any);
      this.uri = toClassValue(
        metadata,
        DeviceRegistrationInfo[S_DEFINITION_METADATA],
        'uri',
        schema.uri
      );
      this.id = toClassValue(
        metadata,
        DeviceRegistrationInfo[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
    }

    public _assignFrom(schema: IDeviceRegistrationInfo) {
      this.uri = toClassValue(
        metadata,
        DeviceRegistrationInfo[S_DEFINITION_METADATA],
        'uri',
        schema.uri
      );
      this.id = toClassValue(
        metadata,
        DeviceRegistrationInfo[S_DEFINITION_METADATA],
        'id',
        schema.id
      );
    }

    public static isInstance(o: any): boolean {
      return (
        o[S_DEFINITION_NAME] === DeviceRegistrationInfo.SWAGGER_DEFINITION_NAME
      );
    }

    public [S_METHOD_TO_JSON_OBJECT](): IJsonObject {
      return {
        uri: toJsonObject(
          metadata,
          DeviceRegistrationInfo[S_DEFINITION_METADATA],
          'uri',
          this['uri']
        ),
        id: toJsonObject(
          metadata,
          DeviceRegistrationInfo[S_DEFINITION_METADATA],
          'id',
          this['id']
        ),
      };
    }
  }

  Object.defineProperty(DeviceRegistrationInfo, S_DEFINITION_NAME, {
    get: () => 'DeviceRegistrationInfo',
  });

  Object.defineProperty(DeviceRegistrationInfo, S_DEFINITION_METADATA, {
    get: () => ({
      uri: { type: 'string', format: 'uri', example: 'http://10.0.0.220:8080' },
      id: {
        type: 'string',
        format: 'uuid',
        example: '0729a580-2240-11e6-9eb5-0002a5d5c51b',
      },
    }),
  });
}

export function isSwaggerDefinition(o: any): boolean {
  return typeof o[S_DEFINITION_NAME] !== 'undefined';
}

export function getSwaggerDefinitionName(o: any): string {
  return o[S_DEFINITION_NAME];
}

export function swaggerDefinitionToJson(o: any): IJsonObject {
  return o[S_METHOD_TO_JSON_OBJECT]();
}

export const metadata = Object.freeze({
  isSwaggerDefinition,
  getSwaggerDefinitionName,
  swaggerDefinitionToJson,
  classes: [
    definition.ManyTypes,
    definition.ManyTypesApiResponse,
    definition.LightingSummary,
    definition.LightingZone,
    definition.LightingZoneStatus,
    definition.TemperatureSummary,
    definition.TemperatureZone,
    definition.TemperatueZoneStatus,
    definition.ApiResponse,
    definition.HeaterState,
    definition.DeviceState,
    definition.ForecastResponse,
    definition.Forecast,
    definition.City,
    definition.ForecastTemperature,
    definition.WeatherForecast,
    definition.DeviceRegistrationInfo,
  ],
  definitions: {
    '#/definitions/ManyTypes': {
      type: 'object',
      description: 'types test',
      properties: {
        number32: { type: 'integer', format: 'int32' },
        number64: { type: 'integer', format: 'int64' },
        simpleText: { type: 'string' },
        binaryText: { type: 'string', format: 'byte' },
        timestamp: { type: 'string', format: 'date-time' },
      },
      example: {
        number32: 123456789,
        number64: 2166572391,
        simpleText: 'hello world',
        binaryText: '\u0000\u0001\u0002',
        timestamp: '2020-05-09T07:15:01.391Z',
      },
    },
    '#/definitions/ManyTypesApiResponse': {
      type: 'object',
      properties: {
        code: { type: 'integer', format: 'int32' },
        message: { type: 'string', example: 'everything is ok' },
        result: { $ref: '#/definitions/ManyTypes' },
      },
    },
    '#/definitions/LightingSummary': {
      type: 'object',
      properties: {
        zones: { type: 'array', items: { $ref: '#/definitions/LightingZone' } },
        zoneStatus: {
          type: 'array',
          items: { $ref: '#/definitions/LightingZoneStatus' },
        },
      },
      description: 'ok',
    },
    '#/definitions/LightingZone': {
      type: 'object',
      properties: {
        id: { type: 'string' },
        name: { type: 'string' },
        deviceId: { type: 'integer', format: 'int32' },
        deviceType: { type: 'string', enum: ['dimmer', 'switch'] },
        zone: { type: 'string' },
      },
    },
    '#/definitions/LightingZoneStatus': {
      type: 'object',
      properties: {
        id: { type: 'string' },
        name: { type: 'string' },
        lastUpdate: { type: 'string', format: 'date-time' },
        level: { type: 'integer', format: 'int32' },
      },
      description: 'the status of the lighting zone.',
    },
    '#/definitions/TemperatureSummary': {
      type: 'object',
      properties: {
        zones: {
          type: 'array',
          items: { $ref: '#/definitions/TemperatureZone' },
        },
        zoneStatus: {
          type: 'array',
          items: { $ref: '#/definitions/TemperatueZoneStatus' },
        },
      },
      description: 'ok',
    },
    '#/definitions/TemperatureZone': {
      type: 'object',
      required: ['id', 'name'],
      properties: {
        id: {
          type: 'integer',
          format: 'int32',
          description: 'the unique identifier for the zone',
        },
        name: { type: 'string' },
        inputPosition: { type: 'integer', format: 'int32' },
        outputPosition: { type: 'integer', format: 'int32' },
        zone: { type: 'string' },
      },
      description: 'a single temperature zone',
    },
    '#/definitions/TemperatueZoneStatus': {
      type: 'object',
      required: ['id', 'timestamp', 'value'],
      properties: {
        id: {
          type: 'string',
          description: 'the unique identifier for the zone',
        },
        name: { type: 'string', description: 'the name of the zone' },
        value: {
          type: 'number',
          format: 'double',
          description: 'the temperature in the zone',
        },
        units: {
          type: 'string',
          description: 'the temperature units',
          enum: ['celsius', 'fahrenheit'],
          default: 'fahrenheit',
        },
        timestamp: {
          type: 'string',
          format: 'date-time',
          description: 'the timestamp when the temperature was measured',
        },
      },
      description: 'status of a single zone',
    },
    '#/definitions/ApiResponse': {
      type: 'object',
      properties: {
        code: { type: 'integer', format: 'int32' },
        message: { type: 'string', example: 'everything is ok' },
      },
    },
    '#/definitions/HeaterState': {
      type: 'object',
      properties: { id: { type: 'string' }, state: { type: 'string' } },
    },
    '#/definitions/DeviceState': {
      type: 'object',
      properties: {
        id: { type: 'string' },
        name: { type: 'string' },
        lastUpdate: { type: 'string', format: 'date-time' },
        level: { type: 'integer', format: 'int32' },
      },
    },
    '#/definitions/ForecastResponse': {
      type: 'object',
      properties: {
        city: { $ref: '#/definitions/City' },
        values: { type: 'array', items: { $ref: '#/definitions/Forecast' } },
      },
    },
    '#/definitions/Forecast': {
      type: 'object',
      properties: {
        date: { type: 'string', format: 'date-time' },
        pressure: { type: 'number', format: 'double' },
        humidity: { type: 'integer', format: 'int32' },
        windSpeed: { type: 'number', format: 'double' },
        clouds: { type: 'integer', format: 'int32' },
        temperature: { $ref: '#/definitions/ForecastTemperature' },
        weather: { $ref: '#/definitions/WeatherForecast' },
      },
    },
    '#/definitions/City': {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        name: { type: 'string' },
        lat: { type: 'number', format: 'double' },
        lon: { type: 'number', format: 'double' },
        country: { type: 'string' },
      },
    },
    '#/definitions/ForecastTemperature': {
      type: 'object',
      properties: {
        low: { type: 'number', format: 'double' },
        high: { type: 'number', format: 'double' },
        morning: { type: 'number', format: 'double' },
        day: { type: 'number', format: 'double' },
        evening: { type: 'number', format: 'double' },
        night: { type: 'number', format: 'double' },
      },
    },
    '#/definitions/WeatherForecast': {
      type: 'object',
      properties: {
        summary: { type: 'string' },
        description: { type: 'string' },
        icon: { type: 'string' },
      },
    },
    '#/definitions/DeviceRegistrationInfo': {
      type: 'object',
      properties: {
        uri: {
          type: 'string',
          format: 'uri',
          example: 'http://10.0.0.220:8080',
        },
        id: {
          type: 'string',
          format: 'uuid',
          example: '0729a580-2240-11e6-9eb5-0002a5d5c51b',
        },
      },
    },
  },
});

export interface definitions {
  ManyTypes: definition.ManyTypes;
  ManyTypesApiResponse: definition.ManyTypesApiResponse;
  LightingSummary: definition.LightingSummary;
  LightingZone: definition.LightingZone;
  LightingZoneStatus: definition.LightingZoneStatus;
  TemperatureSummary: definition.TemperatureSummary;
  TemperatureZone: definition.TemperatureZone;
  TemperatueZoneStatus: definition.TemperatueZoneStatus;
  ApiResponse: definition.ApiResponse;
  HeaterState: definition.HeaterState;
  DeviceState: definition.DeviceState;
  ForecastResponse: definition.ForecastResponse;
  Forecast: definition.Forecast;
  City: definition.City;
  ForecastTemperature: definition.ForecastTemperature;
  WeatherForecast: definition.WeatherForecast;
  DeviceRegistrationInfo: definition.DeviceRegistrationInfo;
}

export interface Device {
  /**
   * getDevices
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getDevices(
    options?: ApiRequestOptionsXO<never, { skip: any; limit: any }>
  ): Promise<ApiResponse<string[], { [key: string]: any }>>;

  /**
   * register
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  register(
    options?: ApiRequestOptionsOX<
    definition.IDeviceRegistrationInfo | definition.DeviceRegistrationInfo,
    {}
    >
  ): Promise<ApiResponse<never, { [key: string]: any }>>;
}

export interface TestApi {
  /**
   * getManyTypes
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getManyTypes(
    options: ApiRequestOptionsRX<
    definition.IManyTypes | definition.ManyTypes,
    {}
    >
  ): Promise<
  ApiResponse<definition.ManyTypesApiResponse, { [key: string]: any }>
  >;
}

export interface ZWave {
  /**
   * setDimmer
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  setDimmer(
    options: ApiRequestOptionsXR<never, { deviceId: any; value: any }>
  ): Promise<ApiResponse<definition.ApiResponse, { [key: string]: any }>>;

  /**
   * setDimmerTimer
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  setDimmerTimer(
    options: ApiRequestOptionsXR<
    never,
    { deviceId: any; value: any; timeunit: any; units: any }
    >
  ): Promise<ApiResponse<definition.ApiResponse, { [key: string]: any }>>;

  /**
   * getSwitchState
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getSwitchState(
    options: ApiRequestOptionsXR<never, { deviceId: any }>
  ): Promise<ApiResponse<definition.DeviceState, { [key: string]: any }>>;

  /**
   * setSwitch
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  setSwitch(
    options: ApiRequestOptionsXR<never, { deviceId: any; value: any }>
  ): Promise<ApiResponse<definition.ApiResponse, { [key: string]: any }>>;

  /**
   * setSwitchTimer
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  setSwitchTimer(
    options: ApiRequestOptionsXR<
    never,
    { deviceId: any; value: any; minutes: any }
    >
  ): Promise<ApiResponse<definition.ApiResponse, { [key: string]: any }>>;

  /**
   * getLightingSummary
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getLightingSummary(
    options?: ApiRequestOptionsXX<never, {}>
  ): Promise<ApiResponse<definition.LightingSummary, { [key: string]: any }>>;
}

export interface Environment {
  /**
   * temperatureSummary
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  temperatureSummary(
    options?: ApiRequestOptionsXX<never, {}>
  ): Promise<
  ApiResponse<definition.TemperatureSummary, { [key: string]: any }>
  >;

  /**
   * getForecast
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getForecast(
    options: ApiRequestOptionsXR<never, { days: any }>
  ): Promise<ApiResponse<definition.ForecastResponse, { [key: string]: any }>>;

  /**
   * getZoneTemperature
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getZoneTemperature(
    options: ApiRequestOptionsXR<never, { zoneId: any }>
  ): Promise<
  ApiResponse<definition.TemperatueZoneStatus, { [key: string]: any }>
  >;

  /**
   * getHeaterState
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getHeaterState(
    options: ApiRequestOptionsXR<never, { zoneId: any }>
  ): Promise<ApiResponse<definition.HeaterState, { [key: string]: any }>>;

  /**
   * setHeaterState
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  setHeaterState(
    options: ApiRequestOptionsXR<never, { zoneId: any; state: any }>
  ): Promise<ApiResponse<definition.ApiResponse, { [key: string]: any }>>;
}

export interface Zones {
  /**
   * getZones
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  getZones(
    options?: ApiRequestOptionsXX<never, {}>
  ): Promise<ApiResponse<string[], { [key: string]: any }>>;

  /**
   * quietZone
   *
   * @throws {ApiError}
   * @return {Promise<ApiResponse<?>>}
   */
  quietZone(
    options: ApiRequestOptionsXR<never, { zoneId: any }>
  ): Promise<ApiResponse<never, { [key: string]: any }>>;
}

export const APIS = Object.freeze({
  Device: {
    tag: 'Device',
    specMetadata: metadata,
  },
  TestApi: {
    tag: 'TestApi',
    specMetadata: metadata,
  },
  ZWave: {
    tag: 'Z-Wave',
    specMetadata: metadata,
  },
  Environment: {
    tag: 'Environment',
    specMetadata: metadata,
  },
  Zones: {
    tag: 'Zones',
    specMetadata: metadata,
  },
});
